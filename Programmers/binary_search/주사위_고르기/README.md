## 프로그래머스 2024 KAKAO WINTER INTERNSHIP 주사위 고르기

### 문제 설명

A와 B가 n개의 주사위를 가지고 승부를 합니다. 주사위의 6개 면에 각각 하나의 수가 쓰여 있으며, 주사위를 던졌을 때 각 면이 나올 확률은 동일합니다. 각 주사위는 1 ~ n의 번호를 가지고 있으며, 주사위에 쓰인 수의 구성은 모두 다릅니다.

A가 먼저 n / 2개의 주사위를 가져가면 B가 남은 n / 2개의 주사위를 가져갑니다. 각각 가져간 주사위를 모두 굴린 뒤, 나온 수들을 모두 합해 점수를 계산합니다. 점수가 더 큰 쪽이 승리하며, 점수가 같다면 무승부입니다.

A는 자신이 승리할 확률이 가장 높아지도록 주사위를 가져가려 합니다.

주사위에 쓰인 수의 구성을 담은 2차원 정수 배열 dice가 매개변수로 주어집니다. 이때, 자신이 승리할 확률이 가장 높아지기 위해 A가 골라야 하는 주사위 번호를 오름차순으로 1차원 정수 배열에 담아 return 하도록 solution 함수를 완성해 주세요. 승리할 확률이 가장 높은 주사위 조합이 유일한 경우만 주어집니다.

#### 입력

2 ≤ dice의 길이 = n ≤ 10

- n은 2의 배수입니다.
- dice[i]는 i+1번 주사위에 쓰인 6개의 수를 담고 있습니다.
- dice[i]의 길이 = 6
- 1 ≤ dice[i]의 원소 ≤ 100

#### 출력

A가 선택한 주사위 번호를 배열 형태로 반환

### 문제 접근

주사위의 개수가 총 10개인 경우가 최대, 주사위의 면이 6개로 고정되어 있으므로 n이 별로 크지 않아 완전탐색을 진행해도 괜찮을거라고 생각했음!

A가 가져가는 모든 주사위의 조합에 대해서 A가 이기는 횟수를 각각 구해서 이기는 횟수가 최대인 경우의 조합을 반환

A가 가져가는 모든 주사위의 조합 -> dfs

각 조합에 대해서 A의 승수를 판단하는 로직

```
get_win_cnt(A가 선택한 주사위들, B가 선택한 주사위들) {
  a_points = A가 고른 주사위로 만들 수 있는 모든 수 리스트
  b_points = B가 고른 주사위로 만들 수 있는 모든 수 리스트

  // 이진 탐색으로 승수 계산
  b_points 오름차순 정렬

  for(모든 a_point에 대해서 승수 계산) {
    // 나보다 작은 값 중 최대인 값의 index 찾기
    // 시작점과 끝점이 뒤집어지는 순간 멈춤
    while (start <= end) {
      if a > b {
        start = mid + 1
      } else {
        end = mid - 1
      }
    }

    // start - 1이 내가 찾고자 하는 index
    승수 개수 누적
  }

  return 이긴 횟수
}
```

처음에는 승리 여부를 판단하는 로직에서도 완전탐색을 사용했음.

a의 모든 나올 수 있는 숫자 구성에 대해서 모든 b의 구성과 비교하면서 이긴 횟수를 셌다.

당연히 시간 초과가 남... $6^5 \times 6^5$인데 안날리가 없음...

그래서 승수를 좀 한번에 세는 방법을 써야겠다고 생각해서 이분탐색으로 이길 수 있는 값들의 index를 찾아서 바로 이긴 횟수에 더해서 누적하는 방식으로 진행했음!

$6^5 log6^5$ 으로 줄일 수 있다. (a의 모든 점수에 대해서 모두 돌려보되 이진탐색으로 $log6^5$)

시간 더 줄이려면 중복된 합 나오는 경우는 저장해놨던 값에서 찾아서 바로 누적하는 등 a의 점수를 돌지 않는 방법도 있을듯..! 근데 일단 여기 테케는 저정도로 다 잘 돌아감!
