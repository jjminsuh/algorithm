## 백준 2512 숨바꼭질

### 문제 설명

https://www.acmicpc.net/problem/1697

수빈이는 현재 점 N(0 ≤ N ≤ 100,000)에 있고, 동생은 점 K(0 ≤ K ≤ 100,000)에 있다.

수빈이의 위치가 X일 때 걷는다면 1초 후에 X-1 또는 X+1로 이동하게 된다. 순간이동을 하는 경우에는 1초 후에 2*X의 위치로 이동

수빈이가 동생을 찾을 수 있는 가장 빠른 시간이 몇 초 후인지 구하는 프로그램을 작성하시오.

#### 입력
첫 번째 줄에 수빈이가 있는 위치 N과 동생이 있는 위치 K가 주어진다. N과 K는 정수이다.

#### 출력
수빈이가 동생을 찾는 가장 빠른 시간을 출력한다.

### 문제 접근

1. 수빈이의 위치가 동생보다 큰 경우
    
    수빈이는 무조건 -1로 계속 이동하면서 동생을 찾아야함

    즉, answer의 값이 n - k가 됨

2. 수빈이의 위치와 동생의 위치가 같은 경우

    바로 동생을 찾음, answer = 0

3. 수빈이의 위치가 동생보다 작은 경우

    BFS로 수빈이의 다음 위치를 순회하면서 동생을 찾음

### 코드 간단 설명
```
if n >= k  // 1, 2의 경우
  answer = n - k
else  // 3의 경우
  큐에 다음 수빈이의 위치를 삽입하며 k에 도착할 때까지 순회
  수빈이의 다음 위치는 +1, -1, *2 세 가지 위치가 되며 이미 방문한 위치는 방문하지 않는다.
```

#### 주의해야할 점
- 수빈이의 위치가 동생을 넘어섰다가 돌아오는 것은 가능하지만 MAX_VALUE인 100000을 넘어서는 것은 불가능하다. 수빈이의 다음 위치가 0보다 작거나 MAX_VALUE를 넘어서지 않도록 처리해야 함.

- visited 배열은 0이 아니라 -1로 초기화했다. 해당 배열에 수빈이의 처음 위치에서 출발했을 때 각 위치로 가는 최소 시간을 저장했기 때문에 방문하지 않은 칸은 -1로 표시(수빈이의 처음 위치가 배열 값이 0이 됨).





