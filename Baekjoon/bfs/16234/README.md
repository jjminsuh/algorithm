## 백준 16234 인구이동

### 문제 설명

https://www.acmicpc.net/problem/16234

N×N크기의 땅이 있고, 땅은 1×1개의 칸으로 나누어져 있다. 각각의 땅에는 나라가 하나씩 존재하며, r행 c열에 있는 나라에는 A[r][c]명이 살고 있다. 인접한 나라 사이에는 국경선이 존재한다. 모든 나라는 1×1 크기이기 때문에, 모든 국경선은 정사각형 형태이다.

인구 이동은 하루 동안 다음과 같이 진행되고, 더 이상 아래 방법에 의해 인구 이동이 없을 때까지 지속된다.

- 국경선을 공유하는 두 나라의 인구 차이가 L명 이상, R명 이하라면, 두 나라가 공유하는 국경선을 오늘 하루 동안 연다.
- 위의 조건에 의해 열어야하는 국경선이 모두 열렸다면, 인구 이동을 시작한다.
- 국경선이 열려있어 인접한 칸만을 이용해 이동할 수 있으면, 그 나라를 오늘 하루 동안은 연합이라고 한다.
- 연합을 이루고 있는 각 칸의 인구수는 (연합의 인구수) / (연합을 이루고 있는 칸의 개수)가 된다. 편의상 소수점은 버린다.
- 연합을 해체하고, 모든 국경선을 닫는다.

각 나라의 인구수가 주어졌을 때, 인구 이동이 며칠 동안 발생하는지 구하는 프로그램을 작성하시오.


#### 입력
첫째 줄에 N, L, R이 주어진다. (1 ≤ N ≤ 50, 1 ≤ L ≤ R ≤ 100)

둘째 줄부터 N개의 줄에 각 나라의 인구수가 주어진다. r행 c열에 주어지는 정수는 A[r][c]의 값이다. (0 ≤ A[r][c] ≤ 100)

인구 이동이 발생하는 일수가 2,000번 보다 작거나 같은 입력만 주어진다.

#### 출력
인구 이동이 며칠 동안 발생하는지 첫째 줄에 출력한다.

### 문제 접근

BFS로 탐색해서 문제 주어진대로 구현하면 되는 문제이다.

문제가 길어서 작은 문제로 쪼개서 구현하고자 했다.

1. 하루에 만들어지는 연합을 계산해서 인구 이동 결과를 만들기

    N*N을 모두 순회하면서 방문하지 않은 도시를 시작점으로 하는 BFS를 돌려 각 연합 별로 인구 이동 결과를 계산해서 업데이트 했다.

2. 오늘 인구 이동이 일어났는지 확인 > 인구 이동이 일어나지 않는다면 더 이상의 인구 이동이 없으므로 알고리즘을 종료한다.

    바깥 while문에 flag를 하나 두어 인구 이동이 한 번이라도 일어난 경우 다음날을 탐색하도록 했다.

사실 거의 모든 경우를 완전탐색하는 방식이라 시간이 오래 걸릴까 걱정했는데 N의 최댓값이 50이기 때문에 충분히 시간 제한 내에 모두 탐색이 가능하다.

### 코드 간단 설명
```
while(flag) //인구 이동이 한번도 일어나지 않은 경우에 계속 탐색
  flag = false;

  // 방문하지 않은 도시로 시작하는 모든 경우의 bfs 탐색 진행
  for i = 0 ~ n - 1
    for j = 0 ~ n - 1
      if 이미 방문한 도시
        다음 도시로 넘어간다
      else
        (i,j) 도시를 시작점으로 하는 bfs 시작
        연합 조건을 만족하는 도시를 모두 저장

        if cnt > 1 //연합에 2개 이상의 도시 존재
          flag = true    // 인구 이동이 일어나므로
          인구수 업데이트    // sum/cnt로 인구수 바꿔줌
        
        if flag
          인구 이동이 일어나지 않았으므로 전체 while문 종료
        else
          answer++
          visited 초기화 후 다음 날의 탐색 진행 할 수 있도록 함
```

#### 주의해야할 점
- 구현 아이디어만 접근하면 문제에서 요구한 사항대로 구현하면 된다. edge 케이스들만 조심할 것!

