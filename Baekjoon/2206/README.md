## 백준 2206 벽 부수고 이동하기

### 문제 설명

https://www.acmicpc.net/problem/2206

맵이 주어졌을 때 최단 경로 구해내기 ((1,1)에서 (N, M)으로 이동)

한 칸씩 이동 가능, 벽을 1개까지 부수고 이동할 수 있다.

#### 입력
첫째 줄에 N(1 ≤ N ≤ 1,000), M(1 ≤ M ≤ 1,000)이 주어진다. 다음 N개의 줄에 M개의 숫자로 맵이 주어진다. (1, 1)과 (N, M)은 항상 0이라고 가정하자.

#### 출력
첫째 줄에 최단 거리를 출력한다. 불가능할 때는 -1을 출력한다.

### 문제 접근

BFS를 이용해서 최단거리를 구하면 된다.

BFS를 위한 Queue에 x, y 좌표 이외에 벽을 부쉈는지에 대한 정보도 함께 저장하여 벽을 1번까지 부술 수 있도록 한다.

### 코드 간단 설명

#### 정답 코드

<<row, column>, 벽에 부딪혔는지 여부, 도달하는데 필요한 거리>를 queue에 넣어서 구현

2개의 visited 배열로 벽을 부수고 도달한 경우와 벽을 부수지 않고 해당 위치에 도달한 경우를 관리

```
if 방문하지 않은 칸
  if 벽을 이전에 부순 적이 없는 경우
    if 벽이 아닌 경우
      해당 칸을 큐에 삽입
      일반 visited 배열에 방문 여부 표시
    else
      해당 칸을 큐에 삽입 (벽을 한 번 부순다)
      벽을 부숴 도달한 visited_breaking 배열에 방문 여부 표시
  else 벽을 이전에 부순 경우
    if 벽을 부숴 방분한 적이 없는 경우 (visited_breaking == 0)
      벽이 아닌 경우에만
      해당 칸을 큐에 삽입
      벽을 부숴 도달한 visited_breaking 배열에 방문 여부 표시
```

queue에서 pop을 할 때 (N,M)에 도달하였는지 확인하여 벽을 부수지 않고 도달한 경우와 부숴서 도달한 경우 중에서 더 빠른 경로를 반환할 수 있도록 했다.


#### 첫번째 시도

<<row, column>, 벽에 부딪혔는지 여부>을 queue에 넣으며 BFS 구현

```
if 방문하지 않은 칸
  if 벽이 아닌 경우
    해당 칸을 큐에 추가
  else
    벽을 부순 경험이 없는 경우에만 해당 칸을 큐에 추가
```

이 방법을 사용하며 무조건 초기에 벽을 부수게 된다.

벽을 나중에 부숴야 해결 가능한 경우, 틀린 답이 나온다

반례 예시
```
6 5
00000
11110
00000
01111
01111
00010 
```

출력값으로 18이 나와야 하지만 처음 코드에서 -1이 출력됨

