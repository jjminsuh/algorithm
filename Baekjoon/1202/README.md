## 백준 1202 보석 도둑

### 문제 설명

https://www.acmicpc.net/problem/1202

상덕이가 털 보석점에는 보석이 총 N개 있다. 각 보석은 무게 Mi와 가격 Vi를 가지고 있다. 상덕이는 가방을 K개 가지고 있고, 각 가방에 담을 수 있는 최대 무게는 Ci이다. 가방에는 최대 한 개의 보석만 넣을 수 있다.

상덕이가 훔칠 수 있는 보석의 최대 가격을 구하는 프로그램을 작성하시오.

#### 입력
첫째 줄에 N과 K가 주어진다. (1 ≤ N, K ≤ 300,000)

다음 N개 줄에는 각 보석의 정보 Mi와 Vi가 주어진다. (0 ≤ Mi, Vi ≤ 1,000,000)

다음 K개 줄에는 가방에 담을 수 있는 최대 무게 Ci가 주어진다. (1 ≤ Ci ≤ 100,000,000)

모든 숫자는 양의 정수이다.

#### 출력
첫째 줄에 상덕이가 훔칠 수 있는 보석 가격의 합의 최댓값을 출력한다.

### 문제 접근

그리디로 풀 수 있을 것 같아서 그리디로 우선 접근했다.

기본적인 아이디어는 입력 값을 먼저 정렬한 후에 최고 값어치의 보석 순서대로 넣을 수 있는 가방을 찾아 넣는 것이다.

이때, 가방은 보석을 넣을 수 있는 값 중 가장 작은 용량을 가진 가방을 사용하는 전략을 사용했다.

처음에 이중 for문을 사용하여 아이디어 그대로 구현하려했지만 시간복잡도 O(N^2)으로 시간초과가 났다.

아이디어를 그대로 이용하되, 주어진 가방에 넣을 수 있는 최고 값어치의 보석을 찾는 방법으로 구현 방식을 바꿨다.

이때 우선순위 큐를 사용하여 가방에 답을 수 있는 최대 무게보다 작은 보석들을 큐에 넣고, 값어치가 가장 큰 값을 answer에 더해나갔다.

### 코드 간단 설명
```
(무게, 값어치) 벡터를 오름차순으로 정렬
가방의 최대 무게 벡터를 오름차순으로 정렬   // 첫 가방에 넣지 못한 보석들은 두 번째 가방에 넣을 수 있는 후보값이 된다.

for 가방을 순회
  for (무게, 값어치)를 순회       // 다음 가방으로 넘어가도 계속 이어서 순회할 예정
    가방에 넣을 수 있는 보석을 우선순위 큐에 저장
    가방에 넣을 수 없는 첫 번째 보석을 만나면 안쪽 for문을 멈춘다  // 하지만 index는 초기화 하지x
  
  해당 가방에 넣을 수 있는 가장 비싼 보석을 큐에서 뽑아서 answer에 더해준다  // 우선순위 큐의 top
```

iteration 인덱스와 큐를 초기화 하지 않고 탐색하여 이중 for문을 효율적으로 돌릴 수 있음

가방을 오름차순으로 정렬했으므로 앞선 가방에 넣을 수 있던 보석은 다음 가방에도 넣을 수 있기 때문에 큐와 인덱스 초기화가 필요없다.

#### 주의해야할 점
- N <= 300,000 이고 C <= 100,000,000 이므로 가능한 answer가 int의 범위를 넘어간다! answer 자료형 선언할 때 주의!



