## 백준 9935 문자열 폭발

### 문제 설명

https://www.acmicpc.net/problem/9935

상근이는 문자열에 폭발 문자열을 심어 놓았다. 폭발 문자열이 폭발하면 그 문자는 문자열에서 사라지며, 남은 문자열은 합쳐지게 된다.

폭발은 다음과 같은 과정으로 진행된다.

- 문자열이 폭발 문자열을 포함하고 있는 경우에, 모든 폭발 문자열이 폭발하게 된다. 남은 문자열을 순서대로 이어 붙여 새로운 문자열을 만든다.
- 새로 생긴 문자열에 폭발 문자열이 포함되어 있을 수도 있다.
- 폭발은 폭발 문자열이 문자열에 없을 때까지 계속된다.

상근이는 모든 폭발이 끝난 후에 어떤 문자열이 남는지 구해보려고 한다. 남아있는 문자가 없는 경우가 있다. 이때는 "FRULA"를 출력한다.

#### 입력
첫째 줄에 문자열이 주어진다. 문자열의 길이는 1보다 크거나 같고, 1,000,000보다 작거나 같다.

둘째 줄에 폭발 문자열이 주어진다. 길이는 1보다 크거나 같고, 36보다 작거나 같다.

두 문자열은 모두 알파벳 소문자와 대문자, 숫자 0, 1, ..., 9로만 이루어져 있다.

#### 출력
첫째 줄에 모든 폭발이 끝난 후 남은 문자열을 출력한다.

### 문제 접근

우선 스택을 활용해야겠다고 생각했다.

check에 앞에서부터 검사할 문자열을 넣고, 폭탄 문자열과 비교

만약에 문자열이 다르다면 가장 앞의 알파벳을 스택에 넣고 다음 알파벳을 check에 붙여 계속 검사 진행

폭탄 문자열이 발견된 경우 check의 문자열을 지우고 스택에서 (폭탄 문자열 길이 - 1)개의 알파벳을 뽑아서 check에 넣는다. 이후 check에 다음 알파벳을 붙여서 계속 검사 진행

### 코드 간단 설명
```
for i = 입력 문자열을 순회
  if check가 폭탄 문자열 보다 짧은 경우
    check에 input[i]를 붙인다
    continue
  
  if check 길이 == 폭탄 문자열 길이
    if check == 폭탄 문자열
      check 초기화 (폭탄 문자열 지우기)
      스택에 있던 알파벳을 뽑아서 (폭탄 문자열 길이 - 1)만큼 check에 복구
      check에 input[i]를 붙인다
    else
      check의 가장 앞 문자 스택에 삽입
      check에 input[i]를 붙인다
```

#### 주의해야할 점
- check를 처음에 string으로 정의하여 코드를 짰다. 하지만 string 앞에 문자를 붙이기 위한 시간 복잡도가 O(N) (N: check 길이)이라 시간 초과가 남
    
    이를 해결하기 위해서 check을 덱으로 선언하여 풀이 진행 > 문자를 앞에 붙이든 뒤에 붙이듯 O(1)에 할 수 있음
    
    마지막에 출력할 때만 덱의 길이만큼 순회해서 answer를 출력해줬다.



